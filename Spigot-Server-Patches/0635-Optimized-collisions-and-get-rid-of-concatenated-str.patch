From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: lukas81298 <lukas81298@gmail.com>
Date: Thu, 7 Jan 2021 17:09:09 +0100
Subject: [PATCH] Optimized collisions and get rid of concatenated streams for
 collision detection


diff --git a/src/main/java/com/destroystokyo/paper/util/misc/CachingCallable.java b/src/main/java/com/destroystokyo/paper/util/misc/CachingCallable.java
new file mode 100644
index 0000000000000000000000000000000000000000..f1470c1845a99836d3c8d66d137bd1b15221206b
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/misc/CachingCallable.java
@@ -0,0 +1,20 @@
+package com.destroystokyo.paper.util.misc;
+
+import java.util.concurrent.Callable;
+
+/**
+ * @author Lukas Alt
+ * @since 07.01.2021
+ */
+public abstract class CachingCallable<V> implements Callable<V> {
+    private V cachedValue;
+    @Override
+    public V call() {
+        if(cachedValue == null) {
+            cachedValue = call0();
+        }
+        return cachedValue;
+    }
+
+    protected abstract V call0();
+}
diff --git a/src/main/java/com/destroystokyo/paper/util/voxel/VoxelShapeAccumulator.java b/src/main/java/com/destroystokyo/paper/util/voxel/VoxelShapeAccumulator.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5798f8dde7c3b28c448afbe1d02b139ed2f7188
--- /dev/null
+++ b/src/main/java/com/destroystokyo/paper/util/voxel/VoxelShapeAccumulator.java
@@ -0,0 +1,75 @@
+package com.destroystokyo.paper.util.voxel;
+
+import com.google.common.collect.Lists;
+import net.minecraft.server.VoxelShape;
+
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * This class implements an optimized optimized version of the {@link net.minecraft.server.StreamAccumulator} on top of the{@link net.minecraft.server.VoxelShapeSpliterator}. Instead of a Stream, it returns an iterator and implements the iterable interface.
+ * It provides
+ *
+ * @author Lukas Alt
+ */
+public class VoxelShapeAccumulator implements Iterable<VoxelShape> {
+    public interface VoxelEnumerator {
+        VoxelShape getNext();
+    }
+    private final List<VoxelShape> list = Lists.newArrayList();
+    private final VoxelEnumerator enumerator;
+
+    public VoxelShapeAccumulator(VoxelEnumerator enumerator) {
+        this.enumerator = enumerator;
+    }
+
+    @Override
+    public Iterator<VoxelShape> iterator() {
+        return new Iterator<VoxelShape>() {
+            private int size = 0;
+            private VoxelShape next = null;
+            private boolean saturated = false;
+
+            @Override
+            public boolean hasNext() {
+                if(this.saturated) {
+                    return false;
+                }
+                if(this.size < list.size()) {
+                    return true;
+                }
+                this.next = enumerator.getNext();
+                if(this.next == null) {
+                    this.saturated = true;
+                    return false;
+                }
+                return true;
+            }
+
+            @Override
+            public VoxelShape next() {
+                if(this.size < list.size()) {
+                    return list.get(this.size++);
+                }
+                if(this.saturated) {
+                    throw new IllegalStateException("No more elements");
+                }
+                if(this.next != null) {
+                    final VoxelShape toReturn = this.next;
+                    list.add(next);
+                    this.size++;
+                    this.next = null;
+                    return toReturn;
+                }
+                final VoxelShape next = enumerator.getNext();
+                if(next != null) {
+                    list.add(next);
+                    this.size++;
+                } else {
+                    saturated = true;
+                }
+                return next;
+            }
+        };
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 67487996903f374f306a02788eda5ac014a46fd4..2b8cdb4a433958868a824e601a9f847985710213 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import com.destroystokyo.paper.util.misc.CachingCallable;
+import com.destroystokyo.paper.util.voxel.VoxelShapeAccumulator;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
@@ -619,7 +621,7 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             // Paper end
 
             vec3d = this.a(vec3d, enummovetype);
-            Vec3D vec3d1 = this.g(vec3d);
+            Vec3D vec3d1 = this.collide(vec3d); // Paper - apply OBFHELPER
 
             if (vec3d1.g() > 1.0E-7D) {
                 this.a(this.getBoundingBox().c(vec3d1));
@@ -815,66 +817,85 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return d0;
     }
 
-    private Vec3D g(Vec3D vec3d) {
+    private Vec3D g(Vec3D vec3d) { return collide(vec3d); } // Paper - OBFHELPER
+    private Vec3D collide(Vec3D vec3d) {
         AxisAlignedBB axisalignedbb = this.getBoundingBox();
         VoxelShapeCollision voxelshapecollision = VoxelShapeCollision.a(this);
-        VoxelShape voxelshape = this.world.getWorldBorder().c();
-        Stream<VoxelShape> stream = !this.world.getWorldBorder().isInBounds(axisalignedbb) ? Stream.empty() : Stream.of(voxelshape); // Paper
-        Stream<VoxelShape> stream1 = this.world.c(this, axisalignedbb.b(vec3d), (entity) -> {
-            return true;
-        });
-        StreamAccumulator<VoxelShape> streamaccumulator = new StreamAccumulator<>(Stream.concat(stream1, stream));
-        Vec3D vec3d1 = vec3d.g() == 0.0D ? vec3d : a(this, vec3d, axisalignedbb, this.world, voxelshapecollision, streamaccumulator);
+        // Paper start - get rid of concatenated streams
+        // VoxelShape voxelshape = this.world.getWorldBorder().c();
+        VoxelShape borderShape = !this.world.getWorldBorder().isInBounds(axisalignedbb) ? null : this.world.getWorldBorder().c(); // Paper
+        CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable = new CachingCallable<StreamAccumulator<VoxelShape>>() {
+            @Override
+            public StreamAccumulator<VoxelShape> call0() {
+            return new StreamAccumulator<>(world.getEntityCollisions(Entity.this, axisalignedbb.b(vec3d), (entity) -> {
+                return true;
+            }));
+            }
+        };
+        // Paper end
+        Vec3D vec3d1 = vec3d.g() == 0.0D ? vec3d : collideBoundingBoxHeuristically(this, vec3d.x, vec3d.y, vec3d.z, axisalignedbb, this.world, voxelshapecollision, borderShape, entityCollisionCallable); // Paper
         boolean flag = vec3d.x != vec3d1.x;
         boolean flag1 = vec3d.y != vec3d1.y;
         boolean flag2 = vec3d.z != vec3d1.z;
         boolean flag3 = this.onGround || flag1 && vec3d.y < 0.0D;
 
         if (this.G > 0.0F && flag3 && (flag || flag2)) {
-            Vec3D vec3d2 = a(this, new Vec3D(vec3d.x, (double) this.G, vec3d.z), axisalignedbb, this.world, voxelshapecollision, streamaccumulator);
-            Vec3D vec3d3 = a(this, new Vec3D(0.0D, (double) this.G, 0.0D), axisalignedbb.b(vec3d.x, 0.0D, vec3d.z), this.world, voxelshapecollision, streamaccumulator);
+            Vec3D vec3d2 = collideBoundingBoxHeuristically(this, vec3d.x, this.G, vec3d.z, axisalignedbb, this.world, voxelshapecollision, borderShape, entityCollisionCallable); // Paper
+            Vec3D vec3d3 = collideBoundingBoxHeuristically(this, 0.0D, this.G, 0.0D, axisalignedbb.b(vec3d.x, 0.0D, vec3d.z), this.world, voxelshapecollision, borderShape, entityCollisionCallable); // Paper
 
             if (vec3d3.y < (double) this.G) {
-                Vec3D vec3d4 = a(this, new Vec3D(vec3d.x, 0.0D, vec3d.z), axisalignedbb.c(vec3d3), this.world, voxelshapecollision, streamaccumulator).e(vec3d3);
+                Vec3D vec3d4 = collideBoundingBoxHeuristically(this, vec3d.x, 0.0D, vec3d.z, axisalignedbb.c(vec3d3), this.world, voxelshapecollision, borderShape, entityCollisionCallable).e(vec3d3); // Paper
 
-                if (c(vec3d4) > c(vec3d2)) {
+                if (squaredSize(vec3d4) > squaredSize(vec3d2)) {
                     vec3d2 = vec3d4;
                 }
             }
 
-            if (c(vec3d2) > c(vec3d1)) {
-                return vec3d2.e(a(this, new Vec3D(0.0D, -vec3d2.y + vec3d.y, 0.0D), axisalignedbb.c(vec3d2), this.world, voxelshapecollision, streamaccumulator));
+            if (squaredSize(vec3d2) > squaredSize(vec3d1)) {
+                return vec3d2.e(collideBoundingBoxHeuristically(this, 0.0D, -vec3d2.y + vec3d.y, 0.0D, axisalignedbb.c(vec3d2), this.world, voxelshapecollision, borderShape, entityCollisionCallable)); // Paper
             }
         }
 
         return vec3d1;
     }
 
+    public static double squaredSize(Vec3D vec3d) {
+        return vec3d.x * vec3d.x + vec3d.z * vec3d.z;
+    } // Paper - OBFHELPER
     public static double c(Vec3D vec3d) {
         return vec3d.x * vec3d.x + vec3d.z * vec3d.z;
     }
 
-    public static Vec3D a(@Nullable Entity entity, Vec3D vec3d, AxisAlignedBB axisalignedbb, World world, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) {
-        boolean flag = vec3d.x == 0.0D;
-        boolean flag1 = vec3d.y == 0.0D;
-        boolean flag2 = vec3d.z == 0.0D;
+    public static Vec3D a(@Nullable Entity entity, double vec3d_x, double vec3d_y, double vec3d_z, AxisAlignedBB axisalignedbb, World world, VoxelShapeCollision voxelshapecollision, VoxelShape worldBorderShape, CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable) { return collideBoundingBoxHeuristically(entity, vec3d_x, vec3d_y, vec3d_z, axisalignedbb, world, voxelshapecollision, worldBorderShape, entityCollisionCallable); }// Paper - OBFHELPER
+    public static Vec3D collideBoundingBoxHeuristically(@Nullable Entity entity, double vec3d_x, double vec3d_y, double vec3d_z, AxisAlignedBB axisalignedbb, World world, VoxelShapeCollision voxelshapecollision, VoxelShape worldBorderShape, CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable) { // Paper - get rid of concatenated stream
+        boolean flag = vec3d_x == 0.0D;
+        boolean flag1 = vec3d_y == 0.0D;
+        boolean flag2 = vec3d_z == 0.0D;
 
         if ((!flag || !flag1) && (!flag || !flag2) && (!flag1 || !flag2)) {
-            StreamAccumulator<VoxelShape> streamaccumulator1 = new StreamAccumulator<>(Stream.concat(streamaccumulator.a(), world.b(entity, axisalignedbb.b(vec3d))));
-
-            return a(vec3d, axisalignedbb, streamaccumulator1);
+            // Paper start
+            //StreamAccumulator<VoxelShape> streamaccumulator1 = new StreamAccumulator<>(Stream.concat(streamaccumulator.a(), ));
+            final AxisAlignedBB expandedBB = axisalignedbb.expand(vec3d_x, vec3d_y, vec3d_z); // this creates a expanded copy of the bb, we need to do this here as the bounding box might be modified before the callable is called
+            return collideBoundingBoxLegacy(vec3d_x, vec3d_y, vec3d_z, axisalignedbb, worldBorderShape, entityCollisionCallable, new CachingCallable<VoxelShapeAccumulator>() {
+                @Override
+                protected VoxelShapeAccumulator call0() {
+                    return new VoxelShapeAccumulator(new VoxelShapeSpliterator(world, entity, expandedBB));
+                }
+            });
+            // Paper end
         } else {
-            return a(vec3d, axisalignedbb, world, voxelshapecollision, streamaccumulator);
+            return collideBoundingBox(vec3d_x, vec3d_y, vec3d_z, axisalignedbb, world, voxelshapecollision, worldBorderShape, entityCollisionCallable); // Paper
         }
     }
 
-    public static Vec3D a(Vec3D vec3d, AxisAlignedBB axisalignedbb, StreamAccumulator<VoxelShape> streamaccumulator) {
-        double d0 = vec3d.x;
-        double d1 = vec3d.y;
-        double d2 = vec3d.z;
+    public static Vec3D a(double vec3d_x, double vec3d_y, double vec3d_z, AxisAlignedBB axisalignedbb, VoxelShape worldBorderShape, CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable, CachingCallable<VoxelShapeAccumulator> blockCollisions) { return collideBoundingBoxLegacy(vec3d_x, vec3d_y, vec3d_z, axisalignedbb, worldBorderShape, entityCollisionCallable, blockCollisions); }// Paper  - OBFHELPER
+    public static Vec3D collideBoundingBoxLegacy(double vec3d_x, double vec3d_y, double vec3d_z, AxisAlignedBB axisalignedbb, VoxelShape worldBorderShape, CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable, CachingCallable<VoxelShapeAccumulator> blockCollisions) { // Paper
+        double d0 = vec3d_x;
+        double d1 = vec3d_y;
+        double d2 = vec3d_z;
 
         if (d1 != 0.0D) {
-            d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, streamaccumulator.a(), d1);
+            d1 = VoxelShapes.collide(EnumDirection.EnumAxis.Y, axisalignedbb, worldBorderShape, entityCollisionCallable, blockCollisions, d1); // Paper
             if (d1 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);
             }
@@ -883,33 +904,34 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         boolean flag = Math.abs(d0) < Math.abs(d2);
 
         if (flag && d2 != 0.0D) {
-            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, streamaccumulator.a(), d2);
+            d2 = VoxelShapes.collide(EnumDirection.EnumAxis.Z, axisalignedbb, worldBorderShape, entityCollisionCallable, blockCollisions, d2); // Paper
             if (d2 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);
             }
         }
 
         if (d0 != 0.0D) {
-            d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, streamaccumulator.a(), d0);
+            d0 = VoxelShapes.collide(EnumDirection.EnumAxis.X, axisalignedbb, worldBorderShape, entityCollisionCallable, blockCollisions, d0); // Paper
             if (!flag && d0 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);
             }
         }
 
         if (!flag && d2 != 0.0D) {
-            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, streamaccumulator.a(), d2);
+            d2 = VoxelShapes.collide(EnumDirection.EnumAxis.Z, axisalignedbb, worldBorderShape, entityCollisionCallable, blockCollisions, d2); // Paper
         }
 
         return new Vec3D(d0, d1, d2);
     }
 
-    public static Vec3D a(Vec3D vec3d, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, VoxelShapeCollision voxelshapecollision, StreamAccumulator<VoxelShape> streamaccumulator) {
-        double d0 = vec3d.x;
-        double d1 = vec3d.y;
-        double d2 = vec3d.z;
+    public static Vec3D a(double vec3d_x, double vec3d_y, double vec3d_z, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, VoxelShapeCollision voxelshapecollision, VoxelShape worldBorderShape, CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable) { return collideBoundingBox(vec3d_x, vec3d_y, vec3d_z, axisalignedbb, iworldreader, voxelshapecollision, worldBorderShape, entityCollisionCallable); } // Paper - OBFHELPER
+    public static Vec3D collideBoundingBox(double vec3d_x, double vec3d_y, double vec3d_z, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, VoxelShapeCollision voxelshapecollision, VoxelShape worldBorderShape, CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable) { // Paper do not pass concatenated stream
+        double d0 = vec3d_x;
+        double d1 = vec3d_y;
+        double d2 = vec3d_z;
 
         if (d1 != 0.0D) {
-            d1 = VoxelShapes.a(EnumDirection.EnumAxis.Y, axisalignedbb, iworldreader, d1, voxelshapecollision, streamaccumulator.a());
+            d1 = VoxelShapes.collide(EnumDirection.EnumAxis.Y, axisalignedbb, iworldreader, d1, voxelshapecollision, worldBorderShape, entityCollisionCallable); // Paper
             if (d1 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(0.0D, d1, 0.0D);
             }
@@ -918,21 +940,21 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         boolean flag = Math.abs(d0) < Math.abs(d2);
 
         if (flag && d2 != 0.0D) {
-            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, streamaccumulator.a());
+            d2 = VoxelShapes.collide(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, worldBorderShape, entityCollisionCallable); // Paper
             if (d2 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(0.0D, 0.0D, d2);
             }
         }
 
         if (d0 != 0.0D) {
-            d0 = VoxelShapes.a(EnumDirection.EnumAxis.X, axisalignedbb, iworldreader, d0, voxelshapecollision, streamaccumulator.a());
+            d0 = VoxelShapes.collide(EnumDirection.EnumAxis.X, axisalignedbb, iworldreader, d0, voxelshapecollision, worldBorderShape, entityCollisionCallable); // Paper
             if (!flag && d0 != 0.0D) {
                 axisalignedbb = axisalignedbb.d(d0, 0.0D, 0.0D);
             }
         }
 
         if (!flag && d2 != 0.0D) {
-            d2 = VoxelShapes.a(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, streamaccumulator.a());
+            d2 = VoxelShapes.collide(EnumDirection.EnumAxis.Z, axisalignedbb, iworldreader, d2, voxelshapecollision, worldBorderShape, entityCollisionCallable); // Paper
         }
 
         return new Vec3D(d0, d1, d2);
diff --git a/src/main/java/net/minecraft/server/ICollisionAccess.java b/src/main/java/net/minecraft/server/ICollisionAccess.java
index 496ebb7453ae4736ac43d319530e2d00b3840fb9..8d8737b5190620714031c4f15c98b2ff9c0522ed 100644
--- a/src/main/java/net/minecraft/server/ICollisionAccess.java
+++ b/src/main/java/net/minecraft/server/ICollisionAccess.java
@@ -48,7 +48,16 @@ public interface ICollisionAccess extends IBlockAccess {
 
     default boolean b(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Predicate<Entity> predicate) {
         try { if (entity != null) entity.collisionLoadChunks = true; // Paper
-        return this.d(entity, axisalignedbb, predicate).allMatch(VoxelShape::isEmpty);
+            // Paper start
+            VoxelShapeSpliterator spliterator = new VoxelShapeSpliterator(this, entity, axisalignedbb);
+            VoxelShape shape;
+            while((shape = spliterator.getNext()) != null) {
+                if(!shape.isEmpty()) {
+                    return false;
+                }
+            }
+            return this.getEntityCollisions(entity, axisalignedbb, predicate).allMatch(VoxelShape::isEmpty);
+            // Paper end
         } finally { if (entity != null) entity.collisionLoadChunks = false; } // Paper
     }
 
diff --git a/src/main/java/net/minecraft/server/VoxelShapeSpliterator.java b/src/main/java/net/minecraft/server/VoxelShapeSpliterator.java
index e841611bb7c36dffec44bb9e74a0a9657a113263..b54396070307a5e9e99557b613707699052bb709 100644
--- a/src/main/java/net/minecraft/server/VoxelShapeSpliterator.java
+++ b/src/main/java/net/minecraft/server/VoxelShapeSpliterator.java
@@ -6,7 +6,7 @@ import java.util.function.BiPredicate;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
 
-public class VoxelShapeSpliterator extends AbstractSpliterator<VoxelShape> {
+public class VoxelShapeSpliterator extends AbstractSpliterator<VoxelShape> implements com.destroystokyo.paper.util.voxel.VoxelShapeAccumulator.VoxelEnumerator { // Paper - implement VoxelEnumerator
 
     @Nullable
     private final Entity a; final Entity getEntity() { return this.a; } // Paper - OBFHELPER
@@ -49,6 +49,93 @@ public class VoxelShapeSpliterator extends AbstractSpliterator<VoxelShape> {
         return this.h && this.b(consumer) || this.a(consumer);
     }
 
+    // Paper start - implement tryAdvance(..) but without the use of consumers, returns null if the spliterator is finished, otherwise, the value is non-null. Copied contents from this.b(Consumer) and this.a(Consumer)
+    @Nullable
+    @Override
+    public final VoxelShape getNext() {
+        if(this.h) {
+            this.h = false;
+            return getWorldBorderShape();
+        }
+        while (true) {
+            if (this.d.a()) {
+
+                int l = this.d.e();
+
+                // Paper - moved up
+                if (l == 3) {
+                    continue;
+                }
+                // Paper end
+
+                final int x = this.d.b();
+                final int y = this.d.c();
+                final int z = this.d.d();
+
+                // Paper start - ensure we don't load chunks
+                Entity entity = this.getEntity();
+                BlockPosition.MutableBlockPosition blockposition_mutableblockposition = this.getMutablePos();
+                boolean far = entity != null && MCUtil.distanceSq(entity.locX(), y, entity.locZ(), x, y, z) > 14;
+                blockposition_mutableblockposition.setValues(x, y, z);
+
+                boolean isRegionLimited = this.getCollisionAccess() instanceof RegionLimitedWorldAccess;
+                IBlockData iblockdata = isRegionLimited ? Blocks.VOID_AIR.getBlockData() : ((!far && entity instanceof EntityPlayer) || (entity != null && entity.collisionLoadChunks)
+                    ? this.getCollisionAccess().getType(blockposition_mutableblockposition)
+                    : this.getCollisionAccess().getTypeIfLoaded(blockposition_mutableblockposition)
+                );
+
+                if (iblockdata == null) {
+                    if (!(entity instanceof EntityPlayer) || entity.world.paperConfig.preventMovingIntoUnloadedChunks) {
+                        return VoxelShapes.of(far ? entity.getBoundingBox() : new AxisAlignedBB(x, y, z, x + 1, y + 1, z + 1)); // Paper - skip allocation
+                    }
+                    continue;
+                }
+                // Paper - moved up
+                // Paper end
+
+                if (!this.i.test(iblockdata, this.e) || l == 1 && !iblockdata.d() || l == 2 && !iblockdata.a(Blocks.MOVING_PISTON)) {
+                    continue;
+                }
+
+                VoxelShape voxelshape = iblockdata.getCollisionShape(this.g, this.e, this.c);
+
+                if (voxelshape == VoxelShapes.b()) { // checks if this is a full cube
+                    if (!this.b.intersects(x, y, z, (double) x + 1.0D, (double) y + 1.0D, (double) z + 1.0D)) {
+                        continue;
+                    }
+
+                    return voxelshape.offset(x, y, z); // the voxel shape collides with the bounding box of the block at (x,y,z). Return this shape
+                }
+
+                // voxelshape does not form a cube
+                VoxelShape voxelshape1 = voxelshape.offset(x, y, z);
+
+                if (!VoxelShapes.applyOperation(voxelshape1, this.f, OperatorBoolean.AND)) {
+                    continue;
+                }
+
+                return voxelshape1;
+            }
+
+            return null;
+        }
+    }
+
+    private VoxelShape getWorldBorderShape() {
+        WorldBorder worldborder = this.g.getWorldBorder();
+        AxisAlignedBB axisalignedbb = this.a.getBoundingBox();
+
+        if (!isBoxFullyInWorldBorder(worldborder, axisalignedbb)) {
+            // Paper start
+            if (worldborder.isInBounds(axisalignedbb.shrink(1.0E-7D)) && !worldborder.isInBounds(axisalignedbb.grow(1.0E-7D))) {
+                return worldborder.asVoxelShape();
+            }
+        }
+
+        return null;
+    }
+    // Paper end
+
     boolean a(Consumer<? super VoxelShape> consumer) {
         while (true) {
             if (this.d.a()) {
@@ -147,6 +234,7 @@ public class VoxelShapeSpliterator extends AbstractSpliterator<VoxelShape> {
         return VoxelShapes.c(voxelshape, VoxelShapes.a(axisalignedbb.shrink(1.0E-7D)), OperatorBoolean.AND);
     }
 
+    public static final boolean isBoxFullyInWorldBorder(WorldBorder worldborder, AxisAlignedBB axisalignedbb) { return a(worldborder, axisalignedbb); } // Paper - OBFHELPER
     public static boolean a(WorldBorder worldborder, AxisAlignedBB axisalignedbb) {
         double d0 = (double) MathHelper.floor(worldborder.e());
         double d1 = (double) MathHelper.floor(worldborder.f());
diff --git a/src/main/java/net/minecraft/server/VoxelShapes.java b/src/main/java/net/minecraft/server/VoxelShapes.java
index e21c747b6c39155c44bf30860681d67b0b29fb12..d8417914271c535c9221508fe10a8dba85f7a2ae 100644
--- a/src/main/java/net/minecraft/server/VoxelShapes.java
+++ b/src/main/java/net/minecraft/server/VoxelShapes.java
@@ -176,6 +176,29 @@ public final class VoxelShapes {
         });
     }
 
+    // Paper start - support
+    public static double collide(EnumDirection.EnumAxis axis, AxisAlignedBB axisalignedbb, VoxelShape worldBorderShape, com.destroystokyo.paper.util.misc.CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable, com.destroystokyo.paper.util.misc.CachingCallable<com.destroystokyo.paper.util.voxel.VoxelShapeAccumulator> blockCollisions, double d0) {
+        if(worldBorderShape != null) {
+            d0 = worldBorderShape.a(axis, axisalignedbb, d0);
+            if (Math.abs(d0) < 1.0E-7D) {
+                return 0.0D;
+            }
+        }
+        for (Iterator<VoxelShape> iterator = entityCollisionCallable.call().a().iterator(); iterator.hasNext(); d0 = iterator.next().a(axis, axisalignedbb, d0)) {
+            if (Math.abs(d0) < 1.0E-7D) {
+                return 0.0D;
+            }
+        }
+        for (Iterator<VoxelShape> iterator = blockCollisions.call().iterator(); iterator.hasNext(); d0 = iterator.next().a(axis, axisalignedbb, d0)) {
+            if (Math.abs(d0) < 1.0E-7D) {
+                return 0.0D;
+            }
+        }
+
+        return d0;
+    }
+    // Paper end
+
     public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, Stream<VoxelShape> stream, double d0) {
         for (Iterator iterator = stream.iterator(); iterator.hasNext(); d0 = ((VoxelShape) iterator.next()).a(enumdirection_enumaxis, axisalignedbb, d0)) {
             if (Math.abs(d0) < 1.0E-7D) {
@@ -186,11 +209,12 @@ public final class VoxelShapes {
         return d0;
     }
 
-    public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, Stream<VoxelShape> stream) {
-        return a(axisalignedbb, iworldreader, d0, voxelshapecollision, EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.Z), stream);
+    public static double a(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, VoxelShape worldBorderShape, com.destroystokyo.paper.util.misc.CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable) { return a(enumdirection_enumaxis, axisalignedbb, iworldreader, d0, voxelshapecollision, worldBorderShape, entityCollisionCallable); } // Paper - OBFHELPER
+    public static double collide(EnumDirection.EnumAxis enumdirection_enumaxis, AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, VoxelShape worldBorderShape, com.destroystokyo.paper.util.misc.CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable) { // Paper
+        return a(axisalignedbb, iworldreader, d0, voxelshapecollision, EnumAxisCycle.a(enumdirection_enumaxis, EnumDirection.EnumAxis.Z), worldBorderShape, entityCollisionCallable);
     }
 
-    private static double a(AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, EnumAxisCycle enumaxiscycle, Stream<VoxelShape> stream) {
+    private static double a(AxisAlignedBB axisalignedbb, IWorldReader iworldreader, double d0, VoxelShapeCollision voxelshapecollision, EnumAxisCycle enumaxiscycle, VoxelShape worldBorderShape, com.destroystokyo.paper.util.misc.CachingCallable<StreamAccumulator<VoxelShape>> entityCollisionCallable) { // Paper
         if (axisalignedbb.b() >= 1.0E-6D && axisalignedbb.c() >= 1.0E-6D && axisalignedbb.d() >= 1.0E-6D) {
             if (Math.abs(d0) < 1.0E-7D) {
                 return 0.0D;
@@ -259,9 +283,14 @@ public final class VoxelShapes {
 
                 double[] adouble = new double[]{d0};
 
-                stream.forEach((voxelshape) -> {
-                    adouble[0] = voxelshape.a(enumdirection_enumaxis2, axisalignedbb, adouble[0]);
+                // Paper start
+                if(worldBorderShape != null) {
+                    adouble[0] = worldBorderShape.a(enumdirection_enumaxis2, axisalignedbb, adouble[0]);
+                }
+                entityCollisionCallable.call().a().forEach(voxelShape -> {
+                    adouble[0] = voxelShape.a(enumdirection_enumaxis2, axisalignedbb, adouble[0]);
                 });
+                // Paper end
                 return adouble[0];
             }
         } else {
