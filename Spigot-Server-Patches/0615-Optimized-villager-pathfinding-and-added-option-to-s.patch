From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: lukas81298 <lukas81298@gommehd.net>
Date: Sat, 12 Dec 2020 01:59:27 +0100
Subject: [PATCH] Optimized villager pathfinding and added option to slow down villagers
 
 The villager pathfinding searches for structures in villages a villager might navigate to (e.g. lecterns). By default, this scans all chunk sections in a horizontal range of 48 blocks. The
 vanilla implementation uses a very complex chain of streams and contains lots of redundant computations and checks way more chunk sections than actually necessary. This patch contains
 a rewritten version of this algorithm which should be about 10 times faster and reduces the pressure on the garbage collector. Using the default configuration, the behavior should not differ from 
 vanilla, however lowering "villageSearchRadius" in the "paper.yml" should boost the performance significantly with just a little inpact on the gameplay.
 Furthermore, this patch adds the option to modify the "cooldown" between consecutive pathfinding calls to the same villager by modifying "villagerBehaviorMinCooldown" and
 "villagerBehaviorMaxCooldown". The cooldown will be a random number of ticks between these two values. The default values do not change the vanilla behavior.


diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 6ab0a51b421dc696aec292f2db955311c9cc31e3..15e5b70508caede9981d249b5fe634773fba53a8 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -462,4 +462,17 @@ public class PaperConfig {
     private static void trackPluginScoreboards() {
         trackPluginScoreboards = getBoolean("settings.track-plugin-scoreboards", false);
     }
+
+    public static int villageSearchRadius = 48;
+    private static void villagerLookForPlaceChunkRange() {
+        villageSearchRadius = getInt("settings.village-search-radius", 48);
+    }
+
+    public static int villagerBehaviorMinCooldown = 0;
+    public static int villagerBehaviorMaxCooldown = 20;
+
+    private static void villagerBehaviorCooldown() {
+        villagerBehaviorMinCooldown = getInt("settings.villager-behavior-cooldown-min", 0);
+        villagerBehaviorMaxCooldown = getInt("settings.villager-behavior-cooldown-max", 20);
+    }
 }
diff --git a/src/main/java/net/minecraft/server/BehaviorFindPosition.java b/src/main/java/net/minecraft/server/BehaviorFindPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..129da93b63fa77c0e05c812cf7882f2072e2aedb
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BehaviorFindPosition.java
@@ -0,0 +1,133 @@
+package net.minecraft.server;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableMap.Builder;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+
+import java.util.*;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
+import net.minecraft.server.VillagePlace.Occupancy;
+
+public class BehaviorFindPosition extends Behavior<EntityCreature> {
+    private final VillagePlaceType b;
+    private final MemoryModuleType<GlobalPos> c;
+    private final boolean d;
+    private final Optional<Byte> e;
+    private long f;
+    private final Long2ObjectMap<BehaviorFindPosition.a> g;
+
+    public BehaviorFindPosition(VillagePlaceType var0, MemoryModuleType<GlobalPos> var1, MemoryModuleType<GlobalPos> var2, boolean var3, Optional<Byte> var4) {
+        super(a(var1, var2));
+        this.g = new Long2ObjectOpenHashMap();
+        this.b = var0;
+        this.c = var2;
+        this.d = var3;
+        this.e = var4;
+    }
+
+    public BehaviorFindPosition(VillagePlaceType var0, MemoryModuleType<GlobalPos> var1, boolean var2, Optional<Byte> var3) {
+        this(var0, var1, var1, var2, var3);
+    }
+
+    private static ImmutableMap<MemoryModuleType<?>, MemoryStatus> a(MemoryModuleType<GlobalPos> var0, MemoryModuleType<GlobalPos> var1) {
+        Builder<MemoryModuleType<?>, MemoryStatus> var2 = ImmutableMap.builder();
+        var2.put(var0, MemoryStatus.VALUE_ABSENT);
+        if (var1 != var0) {
+            var2.put(var1, MemoryStatus.VALUE_ABSENT);
+        }
+
+        return var2.build();
+    }
+
+    protected boolean a(WorldServer var0, EntityCreature var1) {
+        if (this.d && var1.isBaby()) {
+            return false;
+        } else if (this.f == 0L) {
+            this.f = var1.world.getTime() + com.destroystokyo.paper.PaperConfig.villagerBehaviorMinCooldown + (long)var0.random.nextInt(com.destroystokyo.paper.PaperConfig.villagerBehaviorMaxCooldown - com.destroystokyo.paper.PaperConfig.villagerBehaviorMinCooldown); // Paper: Option to slow down villagers
+            return false;
+        } else {
+            return var0.getTime() >= this.f;
+        }
+    }
+
+    protected void a(WorldServer var0, EntityCreature var1, long var2) {
+        this.f = var2 + 20L + com.destroystokyo.paper.PaperConfig.villagerBehaviorMinCooldown + (long)var0.random.nextInt(com.destroystokyo.paper.PaperConfig.villagerBehaviorMaxCooldown - com.destroystokyo.paper.PaperConfig.villagerBehaviorMinCooldown); // Paper: Option to slow down villagers
+        VillagePlace var4 = var0.y();
+        this.g.long2ObjectEntrySet().removeIf((var2x) -> {
+            return !((BehaviorFindPosition.a)var2x.getValue()).b(var2);
+        });
+        Predicate<BlockPosition> var5 = (var2x) -> {
+            BehaviorFindPosition.a var3 = (BehaviorFindPosition.a)this.g.get(var2x.asLong());
+            if (var3 == null) {
+                return true;
+            } else if (!var3.c(var2)) {
+                return false;
+            } else {
+                var3.a(var2);
+                return true;
+            }
+        };
+        //Set<BlockPosition> var6 = var4.b(this.b.c(), var5, var1.getChunkCoordinates(), 48, Occupancy.HAS_SPACE).limit(5L).collect(Collectors.toSet());
+        Set<BlockPosition> var6 = com.destroystokyo.paper.PaperConfig.villageSearchRadius == 0 ?  Collections.emptySet() : var4.getPOIs(var5, this.b.c(), var1.getChunkCoordinates(), com.destroystokyo.paper.PaperConfig.villageSearchRadius, 5, Occupancy.HAS_SPACE); // Paper - faster implementation
+
+        PathEntity var7 = var1.getNavigation().a(var6, this.b.d());
+        if (var7 != null && var7.j()) {
+            BlockPosition var8 = var7.m();
+            var4.c(var8).ifPresent((var4x) -> {
+                var4.a(this.b.c(), (var1x) -> {
+                    return var1x.equals(var8);
+                }, var8, 1);
+                var1.getBehaviorController().setMemory(this.c, GlobalPos.create(var0.getDimensionKey(), var8));
+                this.e.ifPresent((var2_) -> {
+                    var0.broadcastEntityEffect(var1, var2_);
+                });
+                this.g.clear();
+                PacketDebug.c(var0, var8);
+            });
+        } else {
+            Iterator<BlockPosition> var9 = var6.iterator();
+            while(var9.hasNext()) {
+                BlockPosition var9_ = var9.next();
+                this.g.computeIfAbsent(var9_.asLong(), (var3) -> {
+                    return new BehaviorFindPosition.a(var1.world.random, var2);
+                });
+            }
+        }
+
+    }
+
+    static class a {
+        private final Random a;
+        private long b;
+        private long c;
+        private int d;
+
+        a(Random var0, long var1) {
+            this.a = var0;
+            this.a(var1);
+        }
+
+        public void a(long var0) {
+            this.b = var0;
+            int var2 = this.d + this.a.nextInt(40) + 40;
+            this.d = Math.min(var2, 400);
+            this.c = var0 + (long)this.d;
+        }
+
+        public boolean b(long var0) {
+            return var0 - this.b < 400L;
+        }
+
+        public boolean c(long var0) {
+            return var0 >= this.c;
+        }
+
+        public String toString() {
+            return "RetryMarker{, previousAttemptAt=" + this.b + ", nextScheduledAttemptAt=" + this.c + ", currentDelay=" + this.d + '}';
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RegionFileSection.java b/src/main/java/net/minecraft/server/RegionFileSection.java
index 04256a95108b8182e8f808e856e0d2b62165e242..cdb3f33cbf34392f45dba9f581a090a1c6d8d571 100644
--- a/src/main/java/net/minecraft/server/RegionFileSection.java
+++ b/src/main/java/net/minecraft/server/RegionFileSection.java
@@ -55,9 +55,13 @@ public class RegionFileSection<R> extends RegionFileCache implements AutoCloseab
         return (Optional) this.c.get(i);
     }
 
+    // Paper start - skip redundant chunk section lookups
     protected Optional<R> d(long i) {
-        SectionPosition sectionposition = SectionPosition.a(i);
+        return d(SectionPosition.a(i), i);
+    }
 
+    protected Optional<R> d(SectionPosition sectionposition, long i) { // This method can be called if the sectionposition corresponding to this index is already known
+    // Paper end
         if (this.b(sectionposition)) {
             return Optional.empty();
         } else {
diff --git a/src/main/java/net/minecraft/server/VillagePlace.java b/src/main/java/net/minecraft/server/VillagePlace.java
index b926cebd053bef829517c9d9bbf1c609c23ca04a..0ade39641aa7a79a34b3882bcd5ab04371a56fa5 100644
--- a/src/main/java/net/minecraft/server/VillagePlace.java
+++ b/src/main/java/net/minecraft/server/VillagePlace.java
@@ -7,12 +7,7 @@ import it.unimi.dsi.fastutil.longs.Long2ByteOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import java.io.File;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-import java.util.Optional;
-import java.util.Random;
-import java.util.Set;
+import java.util.*;
 import java.util.function.BiConsumer;
 import java.util.function.BooleanSupplier;
 import java.util.function.Predicate;
@@ -37,6 +32,82 @@ public class VillagePlace extends RegionFileSection<VillagePlaceSection> {
         // Paper end - add world parameter
     }
 
+    // Paper start - optimized poi search
+    // replacement for b(Predicate<VillagePlaceType>, Predicate<BlockPosition>, BlockPosition, int, VillagePlace.Occupancy) but already limits the results before sorting
+    public Set<BlockPosition> getPOIs(Predicate<BlockPosition> posFilter, Predicate<VillagePlaceType> typeFilter, BlockPosition blockposition, int range, int limit, VillagePlace.Occupancy villageplace_occupancy) {
+        int chunkRange = Math.floorDiv(range, 16) + 2;
+        int squaredDistance = range * range;
+
+        // compute the indices of this chunk
+        int chunkX = blockposition.getX() >> 4;
+        int chunkZ = blockposition.getZ() >> 4;
+
+        int offset = 0;
+        boolean lastRound = false;
+
+
+        int sect = blockposition.getY() / 16;
+        int rangeSection = (int) Math.ceil(range / 16.0);
+        int minYSection = Math.max(0, sect - rangeSection); // compute the vertical chunk sections we need to consider
+        int maxYSection = Math.min(15, sect + rangeSection);
+
+        List<BlockPosition> results = new ArrayList<>();
+        while (offset <= chunkRange) {
+
+            if(offset == 0) {
+                processChunk(posFilter, typeFilter, blockposition, villageplace_occupancy, results, squaredDistance, chunkX, chunkZ, minYSection, maxYSection);
+            } else {
+                for(int x = -offset; x <= offset; x++) {
+                    for(int z = -offset; z <= offset; z++) {
+                        if(x == offset || z == offset || x == -offset || z == -offset) {
+                            processChunk(posFilter, typeFilter, blockposition, villageplace_occupancy, results, squaredDistance, chunkX + x, chunkZ + z, minYSection, maxYSection);
+                        }
+                    }
+                }
+            }
+
+            if(results.size() >= limit) { // once the desired number of places has been found, do one more iteration as there could be a place in it which is closer
+                if(lastRound) {
+                    break;
+                } else {
+                    lastRound = true;
+                }
+            }
+            offset++;
+        }
+
+        // we only need to sort if we got more candidates than the limit
+        if(results.size() > limit) {
+            results.sort(Comparator.<BlockPosition>comparingInt(b -> b.getX()).thenComparingInt(b -> b.getZ()));
+        }
+        // select the closest positions and add it to the resulting set
+        Set<BlockPosition> ret = new HashSet<>(limit);
+        for (BlockPosition result : results) {
+            if(limit <= 0) {
+                return ret;
+            }
+            ret.add(result);
+            limit--;
+        }
+        return ret;
+    }
+
+    private void processChunk(Predicate<BlockPosition> posFilter, Predicate<VillagePlaceType> typeFilter, BlockPosition blockposition, Occupancy villageplace_occupancy, List<BlockPosition> results, int squaredDistances, int chunkX, int chunkZ, int minYSection, int maxYSection) {
+        for (int i1 = minYSection; i1 <= maxYSection; i1++) {
+            final SectionPosition a = SectionPosition.a(chunkX, i1, chunkZ);
+            Optional<VillagePlaceSection> section = this.d(a, a.s());
+            if(section.isPresent()) {
+                section.get().a(typeFilter, villageplace_occupancy).forEach(record -> {
+                    BlockPosition pos = record.f();
+                    if(pos.distanceSquared(blockposition) <= squaredDistances && posFilter.test(pos)) {
+                        results.add(pos);
+                    }
+                });
+            }
+        }
+    }
+    // Paper end
+
     public void a(BlockPosition blockposition, VillagePlaceType villageplacetype) {
         ((VillagePlaceSection) this.e(SectionPosition.a(blockposition).s())).a(blockposition, villageplacetype);
     }
